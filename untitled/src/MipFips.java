public class MipFips {
    public int mipFips(String s){
        String target="01";
        int ans;
        //模式2
        int cnt=0;
        int len=s.length();
        for(int i=0;i<len;i++){
            cnt+=s.charAt(i)!=target.charAt(i%2)?1:0;
        }
        ans=Math.min(cnt,len-cnt);

        if(len%2==0){
            return ans;
        }
        s+=s;

        for(int i=0;i<len;i++){
            if(s.charAt(i)!=target.charAt(i%2)){
                cnt--;
            }
            if(s.charAt(i+len)!=target.charAt((i+len)%2)){
                cnt++;
            }
        }
       return Math.min(ans,Math.min(cnt,len-cnt));
    }
    // 【理解】：男人1 女人0、 男人女人要交替站位、一个男人配一个女人。因此要0101 或者 1010、 不能男同或女同！
// 如何把 11010这种 男男女男女、 变成正确的顺序呢？
// 操作一： 通过摘下头 拼接到尾使得男女配对，           操作二：直接把s的第一个男人“变性”，达成匹配的目的。
// 先求出最坏情况：全部使用操作二变性 所需的次数。   然后看看能不能用操作一优化（减少一些变性次数）
    public int minFlips2(String s) {
        int len = s.length();
        String target = "01";   // 01模式
        int cnt = 0;
        // 不考虑操作一、只使用操作二时、将s转为0101模式需要cnt次（先计算最坏情况下）
        // s长度为偶数时、就是最坏情况、操作一不起作用）
        for (int i = 0; i < len; i++) {
            cnt += s.charAt(i) != target.charAt(i % 2) ? 1 : 0;
        }
        // 只使用操作二将s转为1010模式需要 len - cnt 次
        int ans = Math.min(cnt, len - cnt);
        // ans结果暂定为 s 只使用操作二达成匹配0101或1010、所需次数中较少的那种

        if (s.length() % 2 == 0) {
            //如果s长度为偶数、那么操作一无法优化（不能通过操作一减少 操作二的次数）
            return ans;
            // 操作一是每次将s的第一个字符摘下来，放在s末尾。 等价于对双倍s的字符串、做滑动窗口、窗口右移一格。

            // s长度是偶数，如果s第一个字符不匹配01或10模式、那使用操作一将该字符放到末尾、也还是不匹配。
            // 因此，s长度是偶数时： 操作一有做跟没做是一样的。
            // 直接返回ans
        }
// ————————else————————————————————> 【s长度是奇数时、可以通过操作一的优化、使得操作二的次数减少】
        // 双倍s、为滑动窗口做准备。
        s += s;
        // 窗口右移一格、 即执行一次操作一： 摘下索引 i 的字符拼接到窗口s的末尾、
// for循环：对s从头开始每个字符做一次操作一，找出其中所需操作二次数最少的结果
//         （毕竟操作一不限次数、我们随便用、只要能让操作二(变性)次数少一点、就行！）
        for (int i = 0; i < len; i++) {
// i就是要摘下的字符。此时的s：即窗口范围是[i+1, i+len]; i+len处的字符就是从i处拼接过来的。

            if (s.charAt(i) != target.charAt(i % 2)) {
// 奇数时、如果要摘的索引i的字符 不匹配01目标、那它放到s末尾后，就能够匹配了。从而可以通过这次操作一节省一次操作二。
// eg: 目标串 010101、 假设s为 11010、 通过操作一摘下的第一个字符为1、和0不匹配，
//  但他放在s末尾后、就匹配上了。(11010 -> 10101)、 因此，通过操作一即可达成匹配目标。节省了一次操作二直接将'1'转为'0'
// s=11010 要成为交替字符串、可以通过操作一变成10101、 或者通过操作二变成01010
//  那肯定选择用操作一啊、因为我们要使用最少的操作二。
//  cnt是只使用操作二使s符合条件所需的次数（最坏情况）、
//  对于当前窗口（当前s）、此时我们发现操作一可以替代操作二、因此cnt次数 - 1;
                cnt -= 1;
            }
            // 如果通过操作一把当前窗口的第一个字符拼接到窗口末尾后（窗口右移一格）、
// 发现这个字符即使通过操作一、还是不能在0101/1010的正确位子上、   那说明对这个字符来说、操作一也没办法了。
// 顽固分子。对于这个字符、操作一也没法优化、  那只能乖乖的执行一次操作二、直接变性。
            if (s.charAt(i + len) != target.charAt((i + len) % 2)) {
                cnt += 1;
            }
            // 一次下来、对于字符i、如果可以仅通过操作一达成匹配、那cnt肯定更小了、那就可以更新结果ans了。
// 一次下来、对于字符i、如果进行了一次操作一后还不行、还需要一次操作二。那就等于没有优化。
            ans = Math.min(ans, Math.min(cnt, len - cnt));
        }
        return ans;
    }


}
